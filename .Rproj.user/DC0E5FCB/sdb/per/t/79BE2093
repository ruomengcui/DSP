{
    "contents" : "create.compustat.panel<-function(){\n\tif(load.data){\n\t\tD1=data.frame(read.table(paste(dataSource, 'toReg1', d.tag, '.txt', sep=\"\"), header=TRUE))\n\t\tD2=data.frame(read.table(paste(dataSource, 'sigmacov1', d.tag, '.txt', sep=\"\"), header=TRUE))\n\t\tkey=lapply(unique(apply(D1[,c(1,2)], 1, list)), unlist)\n\t}\n\t\n\tx=2*(1:H)+1; y=x+1; \n\tA=array(dim=c(H, H, 2))\t\n\tLambda=A\n\t\t\n\tr1=(D1$samp==id[1]) & (D1$key==id[2])\n\tr2=(D2$samp==id[1]) & (D2$key==id[2])\n\tS.cols=substring(names(D2), 2, 2)%in%as.character(0:9)\n\tE=data.matrix(D1[r1, x])\n\tEo=data.matrix(D1[r1, y]) \n\tS=matrix(as.real(D2[r2,S.cols]), sqrt(sum(S.cols)));\n}\n\ncreate.wards.panel<-function(){\n\t#base panel\n\td=llply(c(\"sales\", \"prod\"), function(var){\t\n\t\tx=rbind(melt(read.csv(paste(dataSource, \"Wards/\", var, \"1.csv\", sep=\"\"), header = TRUE), 1:4), melt(read.csv(paste(dataSource, \"Wards/\", var, \"2.csv\", sep=\"\"), header = TRUE), 1:4))\n\t\tx$value=as.numeric(gsub(\",\",\"\", as.character(x$value)))\n\t\tx$year=laply(as.character(x$variable), function(y){as.integer(substr(y,nchar(y)-3,nchar(y)))})\n\t\tx$month=as.integer(substr(x$variable, 2,3))\n\t\tx$quart=x$year+(x$month-1)/12\n\t\tnames(x)[which(names(x)==\"value\")]<-var\n\t\tx[c(1:4, 9, 6)]\n\t})\n\td=merge(d[[1]], d[[2]])\n\td=d[(d$Company != \"\")&(d$sales>30)&(d$prod>30),]\n\tunique.cars=unique(d[1:3])\n\tunique.cars$cid=1:dim(unique.cars)[1]\n\td=merge(d, unique.cars)\t\n\td=d[order(d$cid, d$quart),]\n\td=block.boot(d, 40, 36)\n\td=d[,c(8, 10, 9, 5,  1:4, 6, 7)]\n\t\n\t#create signals\n\td<-ddply(d, c(\"samp\", \"cid\"), function(s){\n\t\t#Remove firms that violate regularity conditions\n\t\tif((length(unique(s$quart))<num.periods)||sum(s$prod)>3/2*sum(s$sales)||sum(s$sales)>3/2*sum(s$prod)) return()\n\t\t\t\n\t\t#Remove quadratic trend, seperate out seasonal shifts, and add detrended and seasonal series back to into s\n\t\ts=s[order(s$nboot),]\n\t\tdetrend=aperm(aaply(s[,c(\"sales\", \"prod\")], 2, function(v){\n\t\t\tquatratic.trend=lm(as.matrix(v)~seq(dim(s)[1])+seq(dim(s)[1])^2)$residuals\n\t\t\tseasonality=lm(as.matrix(quatratic.trend)~as.factor(ceiling(12*(s$quart-floor(s$quart))+1)))\n\t\t\tcbind(seasonality$residuals, seasonality$fitted.values)\n\t\t}), c(2,1,3))\n\t\tappend=c(\".dt\", \".season\")\n\t\tfor(i in seq(append)){\n\t\t\tx=as.data.frame(detrend[,,i])\n\t\t\tnames(x)<-paste(names(x), append[i], sep=\"\")\n\t\t\ts=cbind(s, x)\n\t\t}\n\t\t\n\t\t#Run regressions and get signals; Use X*beta, rather than the fitted values of the regression, because this way we get more forecasts\n\t\tt.vars=ts(cbind(detrend[,,1], detrend[,,1]^2))\n\t\treg.panel=ts(s[,c(\"nboot\", \"sales.dt\", \"prod.dt\")])\n\t\tfor(i in seq(H+p-1)) reg.panel=ts.union(reg.panel, lag(t.vars, -i))\n\t\tY.hat=aperm(aaply(reg.panel[,2:3], 2, function(Y){\n\t\t\tlaply(seq(H), function(h){\n\t\t\t\tX=reg.panel[,3+(h-1)*dim(t.vars)[2]+seq(p*dim(t.vars)[2])]\n\t\t\t\tbeta=lm(as.matrix(Y, length(Y))~X-1)$coefficients\n\t\t\t\tX%*%beta\n\t\t\t})\n\t\t}), 3:1)\n\t\t\n\t\t#Difference forecasts into signals; align signals into epsilon vectors; then add these vectors back to s.\t\t\n\t\tfor(i in 1:2){\n\t\t\tforecasts=cbind(reg.panel[,1+i], Y.hat[,,i], c(rep(NA, H+p), rep(0, dim(Y.hat)[1]-H-p)))\n\t\t\tsignals=-t(diff(t(forecasts)))\n\t\t\tepsilon=as.data.frame(rbind(matrix(rep(NA, p*(H+1)), p), matrix(signals[!is.na(signals)], sum(!is.na(signals[,1])))))\n\t\t\tnames(epsilon)<-paste(c(\"eps\", \"eps^o\")[i], 0:H, sep=\"_\")\n\t\t\ts=cbind(s, epsilon)\n\t\t}\n\t\ts\n\t})\n\tsave(d, file=paste(varSave, 'wards_signal_panel.txt', sep=''))\n}\n\ncreate.sim.panel<-function(H=6, N=2000, S=20, which.alpha=c(0, 1), which.beta=c(0, 3), data.name='sim_signal_panel.txt', num.boot=30, positive.Gamma=T, z.scale=1){\n\talpha.max=1\n  beta.max=1\n  d=ldply(seq(S), function(cid){\n\t\talpha=alpha.max*runif(length(which.alpha))\n\t\tbeta=beta.max*runif(length(which.beta))\n\t\tsignals=mvrnorm(N, rep(0, 2*(H+1)), rwishart(2*(H+1), diag(2*(H+1)))$W)\n\t\tz=mvrnorm(N, rep(0, H+1), rwishart(H+1, z.scale*diag(H+1))$W)\n\t\teps=positive.Gamma*signals[,seq(H+1)]+z\n\t\teta=signals[,H+1+seq(H+1)]\n\t\tepso=eps%*%t(solve.for.A(list(alpha=alpha, which.alpha=which.alpha, beta=beta, which.beta=which.beta, Sigma=cov(eps), Lambda=cov(eta), Gamma=cov(eps, eta), L=0))$A)+eta\n\t\tcolnames(eps)<-paste(\"e_\", seq(dim(eps)[2])-1, sep=\"\")\n\t\tcolnames(epso)<-paste(\"o_\", seq(dim(epso)[2])-1, sep=\"\")\n\t\tcolnames(z)<-paste(\"z_\", seq(dim(z)[2])-1, sep=\"\")\n\t\tnames(alpha)<-paste(\"alpha_\", which.alpha, sep=\"\")\n\t\tnames(beta)<-paste(\"beta_\", which.beta, sep=\"\")\n\t\tquart=seq(N)\n\t\tcbind(cid, quart, merge(merge(rbind(alpha),rbind(beta)), as.data.frame(cbind(eps, epso, z))))\n\t})\n\td=block.boot(d, num.boot, 20)\n\tsave(d, file=paste(varSave, data.name, sep=''))\n}\n\n",
    "created" : 1338329672759.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1837579252",
    "id" : "79BE2093",
    "lastKnownWriteTime" : 1338329746,
    "path" : "/Volumes/d1/code/getA/R/modules/signal_panels.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}